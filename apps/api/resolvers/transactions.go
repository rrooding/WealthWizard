package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	"wealth-wizard/api/graph"
	"wealth-wizard/api/models"

	"github.com/shopspring/decimal"
)

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, input models.NewTransaction) (*models.Transaction, error) {
	transaction := &models.Transaction{
		Isin:     input.Isin,
		Broker:   input.Broker,
		Date:     input.Date,
		Exchange: input.Exchange,
		Amount:   input.Amount,
		Price:    input.Price.Amount,
		Currency: input.Price.Currency,
	}

	// Generate a unique Broker ID
	if *input.BrokerID != "" {
		transaction.BrokerID = *input.BrokerID
	} else {
		brokerId, err := models.GenerateBrokerId(transaction)
		if err != nil {
			return nil, err
		}

		transaction.BrokerID = brokerId
	}

	// Add transaction costs if they are given
	if !decimal.Zero.Equal(input.TransactionCost.Amount) {
		transaction.TransactionCost = &input.TransactionCost.Amount
	}

	// Check if the transaction already exists
	var existingTransaction models.Transaction
	result := r.DB.Where(transaction, "Broker", "BrokerID").First(&existingTransaction)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return &existingTransaction, nil
		}

		return nil, result.Error
	}

	// If the transaction doesnt exist, create it
	result = r.DB.Create(&transaction)
	if result.Error != nil {
		return nil, result.Error
	}

	return transaction, nil
}

// Price is the resolver for the Price field.
func (r *transactionResolver) Price(ctx context.Context, obj *models.Transaction) (*models.Money, error) {
	panic(fmt.Errorf("not implemented: Price - Price"))
}

// TransactionCost is the resolver for the TransactionCost field.
func (r *transactionResolver) TransactionCost(ctx context.Context, obj *models.Transaction) (*models.Money, error) {
	panic(fmt.Errorf("not implemented: TransactionCost - TransactionCost"))
}

// Transaction returns graph.TransactionResolver implementation.
func (r *Resolver) Transaction() graph.TransactionResolver { return &transactionResolver{r} }

type transactionResolver struct{ *Resolver }
